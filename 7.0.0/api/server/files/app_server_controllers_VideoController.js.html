<!DOCTYPE html>
<html lang="en" class="yui-overrride">
<head>
    <meta charset="utf-8">
    <title>app/server/controllers/VideoController.js - OpenVeo Publish server</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700' rel='stylesheet' type='text/css'>
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1 class="blue-main-title">OpenVeo Publish server</h1>
        </div>
        <div class="yui3-u-1-4 version project-version">
            API Docs for: 7.0.0
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ConfigurationController.html">ConfigurationController</a></li>
                                <li><a href="../classes/DirectoryFsWatcher.html">DirectoryFsWatcher</a></li>
                                <li><a href="../classes/DirectoryWatcher.html">DirectoryWatcher</a></li>
                                <li><a href="../classes/ERRORS.html">ERRORS</a></li>
                                <li><a href="../classes/factory.html">factory</a></li>
                                <li><a href="../classes/GoogleOAuthHelper.html">GoogleOAuthHelper</a></li>
                                <li><a href="../classes/HTTP_ERRORS.html">HTTP_ERRORS</a></li>
                                <li><a href="../classes/listener.html">listener</a></li>
                                <li><a href="../classes/LocalProvider.html">LocalProvider</a></li>
                                <li><a href="../classes/mediaPlatformFactory.html">mediaPlatformFactory</a></li>
                                <li><a href="../classes/MediaPlatformProvider.html">MediaPlatformProvider</a></li>
                                <li><a href="../classes/Package.html">Package</a></li>
                                <li><a href="../classes/PackageError.html">PackageError</a></li>
                                <li><a href="../classes/PropertyController.html">PropertyController</a></li>
                                <li><a href="../classes/PropertyProvider.html">PropertyProvider</a></li>
                                <li><a href="../classes/PUBLISH_HOOKS.html">PUBLISH_HOOKS</a></li>
                                <li><a href="../classes/PublishError.html">PublishError</a></li>
                                <li><a href="../classes/PublishManager.html">PublishManager</a></li>
                                <li><a href="../classes/PublishPlugin.html">PublishPlugin</a></li>
                                <li><a href="../classes/PublishPluginApi.html">PublishPluginApi</a></li>
                                <li><a href="../classes/ResumableUpload.html">ResumableUpload</a></li>
                                <li><a href="../classes/STATES.html">STATES</a></li>
                                <li><a href="../classes/StatisticsController.html">StatisticsController</a></li>
                                <li><a href="../classes/TarPackage.html">TarPackage</a></li>
                                <li><a href="../classes/TarPackageError.html">TarPackageError</a></li>
                                <li><a href="../classes/TlsClient.html">TlsClient</a></li>
                                <li><a href="../classes/TlsProvider.html">TlsProvider</a></li>
                                <li><a href="../classes/TYPES.html">TYPES</a></li>
                                <li><a href="../classes/VideoController.html">VideoController</a></li>
                                <li><a href="../classes/VideoPackage.html">VideoPackage</a></li>
                                <li><a href="../classes/VideoPackageError.html">VideoPackageError</a></li>
                                <li><a href="../classes/VideoProvider.html">VideoProvider</a></li>
                                <li><a href="../classes/VimeoProvider.html">VimeoProvider</a></li>
                                <li><a href="../classes/Watcher.html">Watcher</a></li>
                                <li><a href="../classes/WatcherError.html">WatcherError</a></li>
                                <li><a href="../classes/WowzaProvider.html">WowzaProvider</a></li>
                                <li><a href="../classes/YoutubeProvider.html">YoutubeProvider</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/controllers.html">controllers</a></li>
                                <li><a href="../modules/packages.html">packages</a></li>
                                <li><a href="../modules/providers.html">providers</a></li>
                                <li><a href="../modules/publish.html">publish</a></li>
                                <li><a href="../modules/watcher.html">watcher</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: app/server/controllers/VideoController.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

/**
 * @module controllers
 */

var util = require(&#x27;util&#x27;);
var path = require(&#x27;path&#x27;);
var fs = require(&#x27;fs&#x27;);
var async = require(&#x27;async&#x27;);
var openVeoApi = require(&#x27;@openveo/api&#x27;);
var coreApi = process.api.getCoreApi();
var fileSystemApi = openVeoApi.fileSystem;
var configDir = fileSystemApi.getConfDir();
var HTTP_ERRORS = process.requirePublish(&#x27;app/server/controllers/httpErrors.js&#x27;);
var VideoProvider = process.requirePublish(&#x27;app/server/providers/VideoProvider.js&#x27;);
var PropertyProvider = process.requirePublish(&#x27;app/server/providers/PropertyProvider.js&#x27;);
var STATES = process.requirePublish(&#x27;app/server/packages/states.js&#x27;);
var PublishManager = process.requirePublish(&#x27;app/server/PublishManager.js&#x27;);
var mediaPlatformFactory = process.requirePublish(&#x27;app/server/providers/mediaPlatforms/factory.js&#x27;);
var TYPES = process.requirePublish(&#x27;app/server/providers/mediaPlatforms/types.js&#x27;);
var platforms = require(path.join(configDir, &#x27;publish/videoPlatformConf.json&#x27;));
var publishConf = require(path.join(configDir, &#x27;publish/publishConf.json&#x27;));
var MultipartParser = openVeoApi.multipart.MultipartParser;
var ContentController = openVeoApi.controllers.ContentController;
var ResourceFilter = openVeoApi.storages.ResourceFilter;

var env = (process.env.NODE_ENV === &#x27;production&#x27;) ? &#x27;prod&#x27; : &#x27;dev&#x27;;

/**
 * Defines a controller to handle actions relative to videos&#x27; routes.
 *
 * @class VideoController
 * @extends ContentController
 * @constructor
 */
function VideoController() {
  VideoController.super_.call(this);
}

module.exports = VideoController;
util.inherits(VideoController, ContentController);

/**
 * Resolves medias resources urls using CDN url.
 *
 * Medias may have attached resources like files associated to tags, timecodes images, thumbnail image and
 * so on. These resources must be accessible through an url. As all resources must, in the future, reside in
 * a CDN, resolveResourcesUrls transforms all resources URIs to URLs based on CDN.
 *
 * @param {Array} medias The list of medias
 */
function resolveResourcesUrls(medias) {
  var cdnUrl = coreApi.getCdnUrl();
  var removeFirstSlashRegExp = new RegExp(/^\//);

  if (medias &amp;&amp; medias.length) {
    medias.forEach(function(media) {

      // Timecodes
      if (media.timecodes) {
        media.timecodes.forEach(function(timecode) {
          if (timecode.image) {

            if (timecode.image.small)
              timecode.image.small = cdnUrl + timecode.image.small.replace(removeFirstSlashRegExp, &#x27;&#x27;);

            if (timecode.image.large)
              timecode.image.large = cdnUrl + timecode.image.large.replace(removeFirstSlashRegExp, &#x27;&#x27;);
          }
        });
      }

      // Tags
      if (media.tags) {
        media.tags.forEach(function(tag) {
          if (tag.file &amp;&amp; tag.file.basePath)
            tag.file.basePath = cdnUrl + tag.file.basePath.replace(removeFirstSlashRegExp, &#x27;&#x27;);
        });
      }

      // Thumbnail
      if (media.thumbnail)
        media.thumbnail = cdnUrl + media.thumbnail.replace(removeFirstSlashRegExp, &#x27;&#x27;);

      // Local videos are hosted in local and consequently delivered by OpenVeo HTTP server
      if (media.type === TYPES.LOCAL &amp;&amp; media.sources) {
        media.sources.forEach(function(source) {
          if (source.files) {
            source.files.forEach(function(file) {
              if (file.link)
                file.link = cdnUrl + file.link.replace(removeFirstSlashRegExp, &#x27;&#x27;);
            });
          }
        });
      }

    });
  }
}

/**
 * Displays video player template.
 *
 * Checks first if the video id is valid and if the video is published
 * before returning the template.
 *
 * @method displayVideoAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.displayVideoAction = function(request, response, next) {
  var publishPlugin;
  var plugins = process.api.getPlugins();
  response.locals.scripts = [];
  response.locals.css = [];

  plugins.forEach(function(subPlugin) {
    if (subPlugin.name === &#x27;publish&#x27;)
      publishPlugin = subPlugin;
  });

  if (publishPlugin) {
    if (publishPlugin.custom) {
      var customScripts = publishPlugin.custom.scriptFiles;
      var playerScripts = customScripts.publishPlayer;
      response.locals.scripts = response.locals.scripts.concat(
        (customScripts.base || []),
        ((playerScripts &amp;&amp; playerScripts[env]) ? playerScripts[env] : [])
      );
      response.locals.css = response.locals.css.concat(publishPlugin.custom.cssFiles || []);
    }
    response.render(&#x27;player&#x27;, response.locals);
  } else
    next();
};

/**
 * Gets all media platforms available.
 *
 * @example
 *     {
 *       &quot;platforms&quot; : [
 *         ...
 *       ]
 *     }
 *
 * @method getPlatformsAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.getPlatformsAction = function(request, response) {
  response.send({
    platforms: Object.keys(platforms) ? Object.keys(platforms).filter(function(value) {
      return platforms[value];
    }) : []
  });
};

/**
 * Gets a ready media.
 *
 * A ready media is a media with a state set to ready or published.
 * Connected users may have access to ready medias but unconnected users can only access published medias.
 *
 * @example
 *
 *     // Response example
 *     {
 *       &quot;entity&quot; : {
 *         &quot;id&quot;: ..., // The media id
 *         &quot;state&quot;: ..., // The media state
 *         &quot;date&quot;: ..., // The media published date as a timestamp
 *         &quot;type&quot;: ..., // The video associated platform
 *         &quot;errorCode&quot;: ..., // The media error code or -1 if no error
 *         &quot;category&quot;: ..., // The media category
 *         &quot;properties&quot;: {...}, // The media custom properties
 *         &quot;link&quot;: ..., // The media URL
 *         &quot;mediaId&quot;: [...], // The media id on the video platform
 *         &quot;available&quot;: ..., // The media availability on the video platform
 *         &quot;thumbnail&quot;: ..., // The media thumbnail URL
 *         &quot;title&quot;: ..., // The media title
 *         &quot;leadParagraph&quot;: ..., // The media lead paragraph
 *         &quot;description&quot;: ..., // The media description
 *         &quot;chapters&quot;: [...], // The media chapters
 *         &quot;tags&quot;: [...], // The media tags
 *         &quot;cut&quot;: [...], // The media begin and end cuts
 *         &quot;timecodes&quot;: [...], // The media associated images
 *       }
 *     }
 *
 * @method getVideoReadyAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Object} request.params Request&#x27;s parameters
 * @param {String} request.params.id The media id
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.getVideoReadyAction = function(request, response, next) {
  if (!request.params.id) return next(HTTP_ERRORS.GET_VIDEO_READY_MISSING_PARAMETERS);

  var params;
  var self = this;
  var provider = this.getProvider();

  try {
    params = openVeoApi.util.shallowValidateObject(request.params, {
      id: {type: &#x27;string&#x27;, required: true}
    });
  } catch (error) {
    return next(HTTP_ERRORS.GET_VIDEO_READY_WRONG_PARAMETERS);
  }

  // Get video
  provider.getOne(
    new ResourceFilter().equal(&#x27;id&#x27;, params.id),
    null,
    function(getOneError, media) {
      if (getOneError) {
        process.logger.error(getOneError.message, {error: getOneError, method: &#x27;getVideoReadyAction&#x27;});
        return next(HTTP_ERRORS.GET_VIDEO_READY_ERROR);
      }

      if (!media) {
        process.logger.warn(&#x27;Not found&#x27;, {method: &#x27;getVideoReadyAction&#x27;, entity: params.id});
        return next(HTTP_ERRORS.GET_VIDEO_READY_NOT_FOUND);
      }

      // Media not ready
      if (media.state !== STATES.READY &amp;&amp; media.state !== STATES.PUBLISHED)
        return next(HTTP_ERRORS.GET_VIDEO_READY_NOT_READY_ERROR);

      // User without enough privilege to read the media in ready state
      if (media.state === STATES.READY &amp;&amp;
          !self.isUserAuthorized(request.user, media, ContentController.OPERATIONS.READ)
         ) {
        return next(HTTP_ERRORS.GET_VIDEO_READY_FORBIDDEN);
      }

      // Video from video platform already retrieved
      if (!media.type || !media.mediaId || (media.available &amp;&amp; media.sources.length == media.mediaId.length)) {
        resolveResourcesUrls([media]);
        return response.send({
          entity: media
        });
      }

      // Get information about the media from the medias platform
      var mediaPlatformProvider = mediaPlatformFactory.get(media.type, platforms[media.type]);
      var expectedDefinition = media.metadata[&#x27;profile-settings&#x27;][&#x27;video-height&#x27;];

      // Compatibility with old mediaId format
      var mediaId = !Array.isArray(media.mediaId) ? [media.mediaId] : media.mediaId;

      // Get media availability and sources
      mediaPlatformProvider.getMediaInfo(mediaId, expectedDefinition, function(getInfoError, info) {
        if (getInfoError) {
          process.logger.error(getInfoError.message, {error: getInfoError, method: &#x27;getVideoReadyAction&#x27;});
          return next(HTTP_ERRORS.GET_VIDEO_READY_GET_INFO_ERROR);
        }

        media.available = info.available;
        media.sources = info.sources;

        provider.updateOne(new ResourceFilter().equal(&#x27;id&#x27;, media.id), info);

        resolveResourcesUrls([media]);

        return response.send({
          entity: media
        });
      });

    }
  );
};

/**
 * Gets a media.
 *
 * @example
 *
 *     // Response example
 *     {
 *       &quot;entity&quot; : {
 *         &quot;id&quot;: ..., // The media id
 *         &quot;state&quot;: ..., // The media state
 *         &quot;date&quot;: ..., // The media published date as a timestamp
 *         &quot;type&quot;: ..., // The video associated platform
 *         &quot;errorCode&quot;: ..., // The media error code or -1 if no error
 *         &quot;category&quot;: ..., // The media category
 *         &quot;properties&quot;: {...}, // The media custom properties
 *         &quot;link&quot;: ..., // The media URL
 *         &quot;mediaId&quot;: [...], // The media id on the video platform
 *         &quot;available&quot;: ..., // The media availability on the video platform
 *         &quot;thumbnail&quot;: ..., // The media thumbnail URL
 *         &quot;title&quot;: ..., // The media title
 *         &quot;leadParagraph&quot;: ..., // The media lead paragraph
 *         &quot;description&quot;: ..., // The media description
 *         &quot;chapters&quot;: [...], // The media chapters
 *         &quot;tags&quot;: [...], // The media tags
 *         &quot;cut&quot;: [...], // The media begin and end cuts
 *         &quot;timecodes&quot;: [...], // The media associated images
 *       }
 *     }
 *
 * @method getEntityAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Object} request.params Request parameters
 * @param {String} request.params.id The id of the media to retrieve
 * @param {Object} request.query Request query
 * @param {String|Array} [request.query.include] The list of fields to include from returned media
 * @param {String|Array} [request.query.exclude] The list of fields to exclude from returned media. Ignored if
 * include is also specified.
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.getEntityAction = function(request, response, next) {
  if (request.params.id) {
    var entityId = request.params.id;
    var provider = this.getProvider();
    var self = this;
    var query;
    var fields;
    request.query = request.query || {};

    try {
      query = openVeoApi.util.shallowValidateObject(request.query, {
        include: {type: &#x27;array&lt;string&gt;&#x27;},
        exclude: {type: &#x27;array&lt;string&gt;&#x27;}
      });
    } catch (error) {
      return next(HTTP_ERRORS.GET_MEDIA_WRONG_PARAMETERS);
    }

    // Make sure &quot;metadata&quot; field is not excluded
    fields = this.removeMetatadaFromFields({
      exclude: query.exclude,
      include: query.include
    });

    provider.getOne(
      new ResourceFilter().equal(&#x27;id&#x27;, entityId),
      fields,
      function(error, media) {
        if (error) {
          process.logger.error(error.message, {error: error, method: &#x27;getEntityAction&#x27;, entity: entityId});
          return next(HTTP_ERRORS.GET_MEDIA_ERROR);
        }

        if (!media) {
          process.logger.warn(&#x27;Not found&#x27;, {method: &#x27;getEntityAction&#x27;, entity: entityId});
          return next(HTTP_ERRORS.GET_MEDIA_NOT_FOUND);
        }

        // User without enough privilege to read the media
        if (!self.isUserAuthorized(request.user, media, ContentController.OPERATIONS.READ)) {
          return next(HTTP_ERRORS.GET_MEDIA_FORBIDDEN);
        }

        // Video from video platform already retrieved
        if (!media.type || !media.mediaId || (media.available &amp;&amp; media.sources.length == media.mediaId.length)) {
          resolveResourcesUrls([media]);
          return response.send({
            entity: media
          });
        }

        // Get information about the media from the medias platform
        var mediaPlatformProvider = mediaPlatformFactory.get(media.type, platforms[media.type]);
        var expectedDefinition = media.metadata[&#x27;profile-settings&#x27;][&#x27;video-height&#x27;];

        // Compatibility with old mediaId format
        var mediaId = !Array.isArray(media.mediaId) ? [media.mediaId] : media.mediaId;

        // Get media availability and sources
        mediaPlatformProvider.getMediaInfo(mediaId, expectedDefinition, function(getInfoError, info) {
          if (getInfoError) {
            process.logger.error(getInfoError.message, {error: getInfoError, method: &#x27;getEntityAction&#x27;});
            return next(HTTP_ERRORS.GET_MEDIA_GET_INFO_ERROR);
          }

          media.available = info.available;
          media.sources = info.sources;

          provider.updateOne(new ResourceFilter().equal(&#x27;id&#x27;, media.id), info);

          resolveResourcesUrls([media]);

          return response.send({
            entity: media
          });
        });
      }
    );
  } else {

    // Missing id of the media
    next(HTTP_ERRORS.GET_MEDIA_MISSING_PARAMETERS);

  }
};

/**
 * Adds a media.
 *
 * @method addEntityAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Object} request.body The media information as multipart body
 * @param {Object} [request.body.file] The media file as multipart data
 * @param {Object} [request.body.thumbnail] The media thumbnail as multipart data
 * @param {Object} request.body.info The media information
 * @param {String} request.body.info.title The media title
 * @param {Object} [request.body.info.properties] The media custom properties values with property id as keys
 * @param {String} [request.body.info.category] The media category id it belongs to
 * @param {Date|Number|String} [request.body.info.date] The media date
 * @param {String} [request.body.info.leadParagraph] The media lead paragraph
 * @param {String} [request.body.info.description] The media description
 * @param {Array} [request.body.info.groups] The media content groups it belongs to
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.addEntityAction = function(request, response, next) {
  if (!request.body) return next(HTTP_ERRORS.ADD_MEDIA_MISSING_PARAMETERS);

  var self = this;
  var categoriesIds;
  var groupsIds;
  var customProperties;
  var params;
  var provider = this.getProvider();
  var parser = new MultipartParser(request, [
    {
      name: &#x27;file&#x27;,
      destinationPath: publishConf.videoTmpDir,
      maxCount: 1
    },
    {
      name: &#x27;thumbnail&#x27;,
      destinationPath: publishConf.videoTmpDir,
      maxCount: 1
    }
  ]);

  async.parallel([

    // Get the list of categories
    function(callback) {
      coreApi.taxonomyProvider.getTaxonomyTerms(&#x27;categories&#x27;, function(error, terms) {
        if (error) {
          process.logger.error(error.message, {error: error, method: &#x27;addEntityAction&#x27;});
          categoriesIds = [];
        } else
          categoriesIds = openVeoApi.util.getPropertyFromArray(&#x27;id&#x27;, terms, &#x27;items&#x27;);

        callback();
      });
    },

    // Get the list of groups
    function(callback) {
      coreApi.groupProvider.getAll(null, null, {id: &#x27;desc&#x27;}, function(error, groups) {
        if (error) {
          process.logger.error(error.message, {error: error, method: &#x27;addEntityAction&#x27;});
          return callback(HTTP_ERRORS.ADD_MEDIA_GROUPS_ERROR);
        }

        groupsIds = openVeoApi.util.getPropertyFromArray(&#x27;id&#x27;, groups);
        callback();
      });
    },

    // Get the list of custom properties
    function(callback) {
      var database = coreApi.getDatabase();
      var propertyProvider = new PropertyProvider(database);

      propertyProvider.getAll(null, null, {id: &#x27;desc&#x27;}, function(error, properties) {
        if (error) {
          process.logger.error(error.message, {error: error, method: &#x27;addEntityAction&#x27;});
          return callback(HTTP_ERRORS.ADD_MEDIA_CUSTOM_PROPERTIES_ERROR);
        }

        customProperties = properties;
        callback();
      });
    },

    // Parse multipart body
    function(callback) {
      parser.parse(function(error) {
        if (error) {
          process.logger.error(error.message, {error: error, method: &#x27;addEntityAction&#x27;});
          return callback(HTTP_ERRORS.ADD_MEDIA_PARSE_ERROR);
        }

        if (!request.body.info) return callback(HTTP_ERRORS.ADD_MEDIA_MISSING_INFO_PARAMETERS);

        request.body.info = JSON.parse(request.body.info);
        callback();
      });
    }

  ], function(error) {
    if (error) return next(error);

    async.series([

      // Validate file
      function(callback) {
        if (!request.files || !request.files.file || !request.files.file.length)
          return callback(HTTP_ERRORS.ADD_MEDIA_PARSE_ERROR);

        openVeoApi.util.validateFiles({
          file: request.files.file[0].path
        }, {
          file: {in: [fileSystemApi.FILE_TYPES.MP4, fileSystemApi.FILE_TYPES.TAR]}
        }, function(validateError, files) {
          if (validateError || (files.file &amp;&amp; !files.file.isValid)) {
            if (validateError)
              process.logger.error(validateError.message, {error: validateError, method: &#x27;addEntityAction&#x27;});

            callback(HTTP_ERRORS.ADD_MEDIA_WRONG_FILE_PARAMETER);
          } else
            callback();
        });
      },

      // Validate custom properties
      function(callback) {
        var validationDescriptor = {};

        // Iterate through custom properties values
        for (var id in request.body.info.properties) {
          var value = request.body.info.properties[id];

          // Iterate through custom properties descriptors
          for (var i = 0; i &lt; customProperties.length; i++) {
            var customProperty = customProperties[i];
            if (customProperties[i].id === id) {

              // Found custom property description corresponding to the custom property from request
              // Add its validation descriptor

              if (customProperty.type === PropertyProvider.TYPES.BOOLEAN)
                validationDescriptor[id] = {type: &#x27;boolean&#x27;};

              else if (customProperty.type === PropertyProvider.TYPES.LIST &amp;&amp; value !== null)
                validationDescriptor[id] = {type: &#x27;string&#x27;};

              else if (customProperty.type === PropertyProvider.TYPES.TEXT)
                validationDescriptor[id] = {type: &#x27;string&#x27;};

              else if (customProperty.type === PropertyProvider.TYPES.DATE_TIME)
                validationDescriptor[id] = {type: &#x27;number&#x27;};

              break;
            }
          }
        }

        try {
          request.body.info.properties = openVeoApi.util.shallowValidateObject(
            request.body.info.properties,
            validationDescriptor
          );
        } catch (validationError) {
          process.logger.error(validationError.message, {error: validationError, method: &#x27;addEntityAction&#x27;});
          return callback(HTTP_ERRORS.ADD_MEDIA_WRONG_PROPERTIES_PARAMETER);
        }

        callback();
      },

      // Validate other parameters
      function(callback) {
        try {
          var validationDescriptor = {
            title: {type: &#x27;string&#x27;, required: true},
            date: {type: &#x27;number&#x27;, default: Date.now()},
            leadParagraph: {type: &#x27;string&#x27;},
            description: {type: &#x27;string&#x27;},
            groups: {type: &#x27;array&lt;string&gt;&#x27;, in: groupsIds}
          };

          // Avoid getting a category with value &quot;null&quot; (string)
          if (request.body.info.category !== null)
            validationDescriptor.category = {type: &#x27;string&#x27;, in: categoriesIds};

          params = openVeoApi.util.shallowValidateObject(request.body.info, validationDescriptor);

        } catch (validationError) {
          process.logger.error(validationError.message, {error: validationError, method: &#x27;addEntityAction&#x27;});
          return callback(HTTP_ERRORS.ADD_MEDIA_WRONG_PARAMETERS);
        }

        callback();
      },

      // Make sure media does not already exist in database
      function(callback) {
        provider.getOne(
          new ResourceFilter()
          .equal(&#x27;originalPackagePath&#x27;, request.files.file[0].path),
          {
            include: [&#x27;id&#x27;]
          },
          function(getOneError, media) {
            if (getOneError)
              process.logger.error(getOneError.message, {error: getOneError, method: &#x27;addEntityAction&#x27;});

            if (media) callback(HTTP_ERRORS.ADD_MEDIA_CHECK_DUPLICATE_ERROR);
            else callback();
          }
        );
      },

      // Add new media
      function(callback) {
        var pathDescriptor = path.parse(request.files.file[0].path);
        var publishManager = self.getPublishManager();

        var listener = function(mediaPackage) {
          if (mediaPackage.originalPackagePath === request.files.file[0].path) {
            publishManager.removeListener(&#x27;stateChanged&#x27;, listener);
            callback();
          }
        };

        // Make sure process has started before sending back response to the client
        publishManager.on(&#x27;stateChanged&#x27;, listener);

        publishManager.publish({
          originalPackagePath: request.files.file[0].path,
          originalThumbnailPath: request.files.thumbnail ? request.files.thumbnail[0].path : undefined,
          originalFileName: pathDescriptor.name,
          title: params.title,
          date: params.date,
          leadParagraph: params.leadParagraph,
          description: params.description,
          category: params.category,
          groups: params.groups,
          user: request.user.id,
          properties: request.body.info.properties
        });
      }

    ], function(error) {
      if (error) {
        if (request.files &amp;&amp; request.files.file &amp;&amp; request.files.file.length) {

          // Remove temporary file
          fs.unlink(request.files.file[0].path, function(unlinkError) {
            if (unlinkError) {
              process.logger.error(unlinkError.message, {error: unlinkError, method: &#x27;addEntityAction&#x27;});
              return next(HTTP_ERRORS.ADD_MEDIA_REMOVE_FILE_ERROR);
            }
            next(error);
          });

        } else
          next(error);
      } else response.send();
    });
  });
};

/**
 * Updates a media.
 *
 * @example
 *
 *     // Response example
 *     {
 *       &quot;total&quot;: 1
 *     }
 *
 * @method updateEntityAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {String} request.params.id Id of the media to update
 * @param {Object} request.body The media information as multipart body
 * @param {Object} [request.body.thumbnail] The media thumbnail as multipart data
 * @param {Object} request.body.info The media information
 * @param {String} [request.body.info.title] The media title
 * @param {Object} [request.body.info.properties] The media custom properties values with property id as keys
 * @param {String} [request.body.info.category] The media category id it belongs to
 * @param {Date|Number|String} [request.body.info.date] The media date
 * @param {String} [request.body.info.leadParagraph] The media lead paragraph
 * @param {String} [request.body.info.description] The media description
 * @param {Array} [request.body.info.groups] The media content groups it belongs to
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.updateEntityAction = function(request, response, next) {
  if (!request.body || !request.params.id) return next(HTTP_ERRORS.UPDATE_MEDIA_MISSING_PARAMETERS);

  var media;
  var totalUpdated;
  var self = this;
  var mediaId = request.params.id;
  var provider = this.getProvider();
  var parser = new MultipartParser(request, [
    {
      name: &#x27;thumbnail&#x27;,
      destinationPath: publishConf.videoTmpDir,
      maxCount: 1
    }
  ]);

  parser.parse(function(error) {
    if (error) {
      process.logger.error(error.message, {error: error, method: &#x27;updateEntityAction&#x27;});
      next(HTTP_ERRORS.UPDATE_MEDIA_PARSE_ERROR);
    }

    var info = JSON.parse(request.body.info);
    var files = request.files;
    var thumbnail = files.thumbnail ? files.thumbnail[0] : undefined;
    var imageDir = path.normalize(process.rootPublish + &#x27;/assets/player/videos/&#x27; + mediaId);

    async.series([

      // Verify that user has enough privilege to update the media
      function(callback) {
        provider.getOne(
          new ResourceFilter().equal(&#x27;id&#x27;, mediaId), null, function(error, fetchedMedia) {
            if (error) {
              process.logger.error(error.message, {error: error, method: &#x27;updateEntityAction&#x27;});
              return callback(HTTP_ERRORS.UPDATE_MEDIA_GET_ONE_ERROR);
            }

            if (!fetchedMedia) return callback(HTTP_ERRORS.UPDATE_MEDIA_NOT_FOUND_ERROR);

            media = fetchedMedia;

            if (self.isUserAuthorized(request.user, media, ContentController.OPERATIONS.UPDATE)) {

              // User is authorized to update but he must be owner to update the owner
              if (!self.isUserOwner(media, request.user) &amp;&amp;
                  !self.isUserAdmin(request.user) &amp;&amp;
                  !self.isUserManager(request.user)) {
                delete info[&#x27;user&#x27;];
              }

              callback();
            } else
              callback(HTTP_ERRORS.UPDATE_MEDIA_FORBIDDEN);
          }
        );
      },

      // Validate the file
      function(callback) {
        if (!thumbnail) return callback();

        openVeoApi.util.validateFiles(
          {thumbnail: thumbnail.path},
          {thumbnail: {in: [fileSystemApi.FILE_TYPES.JPG]}},
          function(error, files) {
            if (error)
              process.logger.warn(error.message, {error: error, action: &#x27;updateEntity&#x27;, mediaId: mediaId});

            if (!files.thumbnail.isValid) return callback(HTTP_ERRORS.INVALID_VIDEO_THUMBNAIL);

            callback();
          }
        );
      },

      // Copy the file
      function(callback) {
        if (!thumbnail) return callback();

        fileSystemApi.copy(thumbnail.path, path.join(imageDir, &#x27;thumbnail.jpg&#x27;), function(error) {
          if (error) {
            process.logger.warn(
              error.message,
              {error: error, action: &#x27;updateEntityAction&#x27;, mediaId: mediaId, thumbnail: thumbnail.path}
            );
          }

          fileSystemApi.rm(thumbnail.path, function(error) {
            if (error) {
              process.logger.warn(
                error.message,
                {error: error, action: &#x27;updateEntityAction&#x27;, mediaId: mediaId, thumbnail: thumbnail.path}
              );
            }
            callback();
          });
        });
      },

      // Clear image thumbnail cache
      function(callback) {
        if (!thumbnail) return callback();

        coreApi.clearImageCache(path.join(mediaId, &#x27;thumbnail.jpg&#x27;), &#x27;publish&#x27;, function(error) {
          if (error) {
            process.logger.warn(
              error.message,
              {error: error, action: &#x27;updateEntityAction&#x27;, mediaId: mediaId}
            );
          }
          callback();
        });
      },

      // Update the media
      function(callback) {
        if (thumbnail) info.thumbnail = &#x27;/publish/&#x27; + mediaId + &#x27;/thumbnail.jpg&#x27;;

        provider.updateOne(
          new ResourceFilter().equal(&#x27;id&#x27;, mediaId),
          info,
          function(error, total) {
            if (error) {
              process.logger.error(error.message, {error: error, method: &#x27;updateEntityAction&#x27;, entity: mediaId});
              return callback(HTTP_ERRORS.UPDATE_MEDIA_ERROR);
            }

            totalUpdated = total;
            callback();
          }
        );
      },

      // Synchronize the media with the media platform
      function(callback) {
        if (!media.type || !media.mediaId) return callback();

        var mediaPlatformProvider = mediaPlatformFactory.get(media.type, platforms[media.type]);

        mediaPlatformProvider.update(media, info, false, function(error) {
          if (error) {
            process.logger.error(error.message, {error: error, method: &#x27;updateEntityAction&#x27;, entity: mediaId});
            return callback(HTTP_ERRORS.UPDATE_MEDIA_SYNCHRONIZE_ERROR);
          }

          callback();
        });
      }

    ], function(error) {
      if (error) return next(error);
      response.send({total: totalUpdated});
    });
  });
};

/**
 * Gets medias.
 *
 * @example
 *
 *     // Response example
 *     {
 *       &quot;entities&quot; : [ ... ],
 *       &quot;pagination&quot; : {
 *         &quot;limit&quot;: ..., // The limit number of medias by page
 *         &quot;page&quot;: ..., // The actual page
 *         &quot;pages&quot;: ..., // The total number of pages
 *         &quot;size&quot;: ... // The total number of medias
 *     }
 *
 * @method getEntitiesAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Object} request.query Request&#x27;s query parameters
 * @param {String} [request.query.query] To search on both medias title and description
 * @param {String|Array} [request.query.include] The list of fields to include from returned medias
 * @param {String|Array} [request.query.exclude] The list of fields to exclude from returned medias. Ignored if
 * include is also specified.
 * @param {String|Array} [request.query.states] To filter medias by state
 * @param {String} [request.query.dateStart] To filter medias after or equal to a date (in format mm/dd/yyyy)
 * @param {String} [request.query.dateEnd] To get medias before a date (in format mm/dd/yyyy)
 * @param {String|Array} [request.query.categories] To filter medias by category
 * @param {String|Array} [request.query.groups] To filter medias by group
 * @param {String|Array} [request.query.user] To filter medias by user
 * @param {String} [request.query.sortBy=&quot;date&quot;] To sort medias by either **title**, **description**, **date**,
 * **state**, **views** or **category**
 * @param {String} [request.query.sortOrder=&quot;desc&quot;] Sort order (either **asc** or **desc**)
 * @param {String} [request.query.page=0] The expected page
 * @param {String} [request.query.limit=10] To limit the number of medias per page
 * @param {Object} [request.query.properties] A list of properties with the property id as the key and the expected
 * property value as the value
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.getEntitiesAction = function(request, response, next) {
  var params;
  var fields;
  var self = this;
  var medias = [];
  var properties = [];
  var pagination = {};
  var provider = this.getProvider();
  var orderedProperties = [&#x27;title&#x27;, &#x27;description&#x27;, &#x27;date&#x27;, &#x27;state&#x27;, &#x27;views&#x27;, &#x27;category&#x27;];

  try {
    params = openVeoApi.util.shallowValidateObject(request.query, {
      query: {type: &#x27;string&#x27;},
      include: {type: &#x27;array&lt;string&gt;&#x27;},
      exclude: {type: &#x27;array&lt;string&gt;&#x27;},
      states: {type: &#x27;array&lt;number&gt;&#x27;},
      dateStart: {type: &#x27;date&#x27;},
      dateEnd: {type: &#x27;date&#x27;},
      categories: {type: &#x27;array&lt;string&gt;&#x27;},
      groups: {type: &#x27;array&lt;string&gt;&#x27;},
      user: {type: &#x27;array&lt;string&gt;&#x27;},
      properties: {type: &#x27;object&#x27;, default: {}},
      limit: {type: &#x27;number&#x27;, gt: 0},
      page: {type: &#x27;number&#x27;, gte: 0, default: 0},
      sortBy: {type: &#x27;string&#x27;, in: orderedProperties, default: &#x27;date&#x27;},
      sortOrder: {type: &#x27;string&#x27;, in: [&#x27;asc&#x27;, &#x27;desc&#x27;], default: &#x27;desc&#x27;}
    });
  } catch (error) {
    return next(HTTP_ERRORS.GET_VIDEOS_WRONG_PARAMETERS);
  }

  // Build sort
  var sort = {};
  sort[params.sortBy] = params.sortOrder;

  // Build filter
  var filter = new ResourceFilter();

  // Add search query
  if (params.query) filter.search(&#x27;&quot;&#x27; + params.query + &#x27;&quot;&#x27;);

  // Add states
  if (params.states &amp;&amp; params.states.length) filter.in(&#x27;state&#x27;, params.states);

  // Add categories
  if (params.categories &amp;&amp; params.categories.length) filter.in(&#x27;category&#x27;, params.categories);

  // Add groups
  if (params.groups &amp;&amp; params.groups.length) filter.in(&#x27;metadata.groups&#x27;, params.groups);

  // Add owner
  if (params.user &amp;&amp; params.user.length) filter.in(&#x27;metadata.user&#x27;, params.user);

  // Add date
  if (params.dateStart) filter.greaterThanEqual(&#x27;date&#x27;, params.dateStart);
  if (params.dateEnd) filter.lesserThanEqual(&#x27;date&#x27;, params.dateEnd);

  // Make sure &quot;metadata&quot; field is not excluded
  fields = this.removeMetatadaFromFields({
    exclude: params.exclude,
    include: params.include
  });

  async.series([

    // Get the list of custom properties
    function(callback) {
      var database = coreApi.getDatabase();
      var propertyProvider = new PropertyProvider(database);

      propertyProvider.getAll(null, null, {id: &#x27;desc&#x27;}, function(error, propertiesList) {
        if (error) {
          process.logger.error(error.message, {error: error, method: &#x27;getEntitiesAction&#x27;});
          return callback(HTTP_ERRORS.GET_VIDEOS_GET_PROPERTIES_ERROR);
        }
        properties = propertiesList;
        callback(error);
      });
    },

    // Validate custom properties
    function(callback) {
      if (params.properties) {
        var customPropertiesIds = Object.keys(params.properties);
        try {
          for (var i = 0; i &lt; customPropertiesIds.length; i++) {
            for (var j = 0; j &lt; properties.length; j++) {
              if (properties[j].id === customPropertiesIds[i]) {
                var validatedProperty;
                var validationDescriptor = {};

                if (properties[j].type === PropertyProvider.TYPES.BOOLEAN)
                  validationDescriptor[properties[j].id] = {type: &#x27;boolean&#x27;, required: true};

                else if (properties[j].type === PropertyProvider.TYPES.LIST)
                  validationDescriptor[properties[j].id] = {type: &#x27;string&#x27;, required: true};

                else if (properties[j].type === PropertyProvider.TYPES.TEXT)
                  validationDescriptor[properties[j].id] = {type: &#x27;string&#x27;, required: true};

                else if (properties[j].type === PropertyProvider.TYPES.DATE_TIME)
                  validationDescriptor[properties[j].id] = {type: &#x27;date&#x27;, required: true};

                validatedProperty = openVeoApi.util.shallowValidateObject(
                  params.properties,
                  validationDescriptor
                );

                if (validatedProperty[properties[j].id]) {
                  if (properties[j].type === PropertyProvider.TYPES.DATE_TIME) {
                    var startDate = new Date(validatedProperty[properties[j].id]);
                    startDate.setHours(0);
                    startDate.setMinutes(0);
                    startDate.setSeconds(0);
                    startDate.setMilliseconds(0);

                    var endDate = new Date(startDate);
                    endDate.setDate(startDate.getDate() + 1);
                    filter.greaterThanEqual(&#x27;properties.&#x27; + properties[j].id, startDate.getTime());
                    filter.lesserThan(&#x27;properties.&#x27; + properties[j].id, endDate.getTime());
                  } else
                    filter.equal(&#x27;properties.&#x27; + properties[j].id, validatedProperty[properties[j].id]);
                }

                break;
              }
            }
          }
        } catch (validationError) {
          process.logger.error(validationError.message, {error: validationError, method: &#x27;getEntitiesAction&#x27;});
          return callback(HTTP_ERRORS.GET_VIDEOS_CUSTOM_PROPERTIES_WRONG_PARAMETERS);
        }
      }

      callback();
    },

    // Get the list of medias
    function(callback) {
      provider.get(
        self.addAccessFilter(filter, request.user),
        fields,
        params.limit,
        params.page,
        sort,
        function(error, fetchedMedias, fetchedPagination) {
          if (error) {
            process.logger.error(error.message, {error: error, method: &#x27;getEntitiesAction&#x27;});
            return callback(HTTP_ERRORS.GET_VIDEOS_ERROR);
          }
          medias = fetchedMedias;
          pagination = fetchedPagination;
          callback();
        }
      );
    }

  ], function(error) {
    if (error) return next(error);
    if (properties) {

      // Medias may not have custom properties or just some of them.
      // Furthermore only the id and value of properties are stored
      // within medias, not complete information about the properties
      // (no name, no description and no type).
      // Inject all custom properties information inside media objects

      medias.forEach(function(media) {
        if (!media.properties) return;
        var mediaProperties = {};

        properties.forEach(function(property) {

          // Make a copy of property object to add value
          mediaProperties[String(property.id)] = JSON.parse(JSON.stringify(property));
          if (!media.properties[String(property.id)])
            mediaProperties[String(property.id)][&#x27;value&#x27;] = &#x27;&#x27;;
          else
            mediaProperties[String(property.id)][&#x27;value&#x27;] = media.properties[String(property.id)];

        });
        media.properties = mediaProperties;
      });

    }

    resolveResourcesUrls(medias);

    response.send({
      entities: medias,
      pagination: pagination
    });
  });
};

/**
 * Publishes medias.
 *
 * Change the state of medias to published.
 *
 * @example
 *
 *     // Response example
 *     {
 *       &quot;total&quot;: 42
 *     }
 *
 * @method publishVideosAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Object} request.params Request&#x27;s parameters
 * @param {String} request.params.ids A comma separated list of media ids
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.publishVideosAction = function(request, response, next) {
  if (!request.params.ids) return next(HTTP_ERRORS.PUBLISH_VIDEOS_MISSING_PARAMETERS);

  var params;
  var self = this;
  var asyncFunctions = [];
  var total = 0;

  try {
    params = openVeoApi.util.shallowValidateObject(request.params, {
      ids: {type: &#x27;string&#x27;, required: true}
    });
  } catch (error) {
    return next(HTTP_ERRORS.PUBLISH_VIDEOS_WRONG_PARAMETERS);
  }

  var ids = params.ids.split(&#x27;,&#x27;);
  var provider = this.getProvider();

  // Make sure user has enough privilege to update the medias
  provider.getAll(
    new ResourceFilter().in(&#x27;id&#x27;, ids),
    {
      include: [&#x27;id&#x27;, &#x27;metadata&#x27;]
    },
    {
      id: &#x27;desc&#x27;
    },
    function(getAllError, medias) {
      if (getAllError) {
        process.logger.error(getAllError.message, {error: getAllError, method: &#x27;publishVideosAction&#x27;});
        return next(HTTP_ERRORS.PUBLISH_VIDEOS_GET_VIDEOS_ERROR);
      }

      medias.forEach(function(media) {
        if (!self.isUserAuthorized(request.user, media, ContentController.OPERATIONS.UPDATE)) return;
        asyncFunctions.push(function(callback) {
          provider.updateOne(
            new ResourceFilter()
            .equal(&#x27;id&#x27;, media.id)
            .equal(&#x27;state&#x27;, STATES.READY),
            {
              state: STATES.PUBLISHED
            },
            function(updateOneError) {
              total++;
              callback(updateOneError);
            }
          );
        });
      });

      async.parallel(asyncFunctions, function(error, results) {
        if (error) {
          process.logger.error(error.message, {error: error, method: &#x27;publishVideosAction&#x27;});
          return next(HTTP_ERRORS.PUBLISH_VIDEOS_ERROR);
        }
        if (total !== ids.length) return next(HTTP_ERRORS.PUBLISH_VIDEOS_FORBIDDEN);

        response.send({
          total: total
        });
      });
    }
  );
};

/**
 * Unpublishes medias.
 *
 * Change the state of medias to unpublished.
 *
 * @example
 *
 *     // Response example
 *     {
 *       &quot;total&quot;: 42
 *     }
 *
 * @method unpublishVideosAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Object} request.params Request&#x27;s parameters
 * @param {String} request.params.ids A comma separated list of media ids
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.unpublishVideosAction = function(request, response, next) {
  if (!request.params.ids) return next(HTTP_ERRORS.UNPUBLISH_VIDEOS_MISSING_PARAMETERS);

  var params;
  var self = this;
  var asyncFunctions = [];
  var total = 0;

  try {
    params = openVeoApi.util.shallowValidateObject(request.params, {
      ids: {type: &#x27;string&#x27;, required: true}
    });
  } catch (error) {
    return next(HTTP_ERRORS.UNPUBLISH_VIDEOS_WRONG_PARAMETERS);
  }

  var ids = params.ids.split(&#x27;,&#x27;);
  var provider = this.getProvider();

  // Make sure user has enough privilege to update the medias
  provider.getAll(
    new ResourceFilter().in(&#x27;id&#x27;, ids),
    {
      include: [&#x27;id&#x27;, &#x27;metadata&#x27;]
    },
    {
      id: &#x27;desc&#x27;
    },
    function(getAllError, medias) {
      if (getAllError) {
        process.logger.error(getAllError.message, {error: getAllError, method: &#x27;unpublishVideosAction&#x27;});
        return next(HTTP_ERRORS.UNPUBLISH_VIDEOS_GET_VIDEOS_ERROR);
      }

      medias.forEach(function(media) {
        if (!self.isUserAuthorized(request.user, media, ContentController.OPERATIONS.UPDATE)) return;
        asyncFunctions.push(function(callback) {
          provider.updateOne(
            new ResourceFilter()
            .equal(&#x27;id&#x27;, media.id)
            .equal(&#x27;state&#x27;, STATES.PUBLISHED),
            {
              state: STATES.READY
            },
            function(updateOneError) {
              total++;
              callback(updateOneError);
            }
          );
        });
      });

      async.parallel(asyncFunctions, function(error, results) {
        if (error) {
          process.logger.error(error.message, {error: error, method: &#x27;unpublishVideosAction&#x27;});
          return next(HTTP_ERRORS.UNPUBLISH_VIDEOS_ERROR);
        }
        if (total !== ids.length) return next(HTTP_ERRORS.UNPUBLISH_VIDEOS_FORBIDDEN);

        response.send({
          total: total
        });
      });
    }
  );
};

/**
 * Retries to publish videos on error.
 *
 * @method retryVideosAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Object} request.params Request&#x27;s parameters
 * @param {String} request.params.ids Comma separated list of media ids
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.retryVideosAction = function(request, response, next) {
  if (!request.params.ids) return next(HTTP_ERRORS.RETRY_VIDEOS_MISSING_PARAMETERS);

  var self = this;
  var params;

  try {
    params = openVeoApi.util.shallowValidateObject(request.params, {
      ids: {type: &#x27;string&#x27;, required: true}
    });
  } catch (error) {
    return next(HTTP_ERRORS.RETRY_VIDEOS_WRONG_PARAMETERS);
  }

  var ids = params.ids.split(&#x27;,&#x27;);
  var asyncFunctions = [];
  var retryAsyncFunction = function(id) {
    return function(callback) {
      var publishManager = self.getPublishManager();
      publishManager.once(&#x27;retry&#x27;, callback);
      publishManager.retry(id);
    };
  };

  for (var i = 0; i &lt; ids.length; i++)
    asyncFunctions.push(retryAsyncFunction(ids[i]));

  async.parallel(asyncFunctions, function() {
    response.send();
  });
};

/**
 * Starts uploading videos to the media platform.
 *
 * @method startUploadAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Object} request.params Request&#x27;s parameters
 * @param {String} request.params.ids Comma separated list of media ids
 * @param {String} request.params.platform The id of the platform to upload to
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.startUploadAction = function(request, response, next) {
  if (!request.params.ids || !request.params.platform) return next(HTTP_ERRORS.START_UPLOAD_VIDEOS_MISSING_PARAMETERS);

  var params;
  var self = this;

  try {
    params = openVeoApi.util.shallowValidateObject(request.params, {
      ids: {type: &#x27;string&#x27;, required: true},
      platform: {type: &#x27;string&#x27;, required: true}
    });
  } catch (error) {
    return next(HTTP_ERRORS.START_UPLOAD_VIDEOS_WRONG_PARAMETERS);
  }

  var ids = params.ids.split(&#x27;,&#x27;);
  var asyncFunctions = [];
  var uploadAsyncFunction = function(id, platform) {
    return function(callback) {
      var publishManager = self.getPublishManager();
      publishManager.once(&#x27;upload&#x27;, callback);
      publishManager.upload(id, platform);
    };
  };

  for (var i = 0; i &lt; ids.length; i++)
    asyncFunctions.push(uploadAsyncFunction(ids[i], params.platform));

  async.parallel(asyncFunctions, function() {
    response.send();
  });
};

/**
 * Gets an instance of the controller associated provider.
 *
 * @method getProvider
 * @return {VideoProvider} The provider
 */
VideoController.prototype.getProvider = function() {
  return new VideoProvider(coreApi.getDatabase());
};

/**
 * Gets PublishManager singleton.
 *
 * @method getPublishManager
 * @return {PublishManager} The PublishManager singleton
 */
VideoController.prototype.getPublishManager = function() {
  return PublishManager.get();
};

/**
 * Updates a tag associated to the given media.
 *
 * If tag does not exist it is created.
 *
 * @example
 *
 *     // Response example
 *     {
 *       &quot;total&quot;: 1,
 *       &quot;tag&quot;: ...
 *     }
 *
 * @method updateTagAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Object} [request.body] Request multipart body
 * @param {Object} [request.body.info] Modifications to perform on the tag
 * @param {Number} [request.body.info.value] The tag time in milliseconds
 * @param {String} [request.body.info.name] The tag name
 * @param {String} [request.body.info.description] The tag description
 * @param {String} [request.body.file] The multipart file associated to the tag
 * @param {Object} request.params Request&#x27;s parameters
 * @param {String} request.params.id The media id the tag belongs to
 * @param {String} [request.params.tagid] The tag id
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.updateTagAction = function(request, response, next) {
  if (!request.params.id) return next(HTTP_ERRORS.UPDATE_TAG_MISSING_PARAMETERS);

  var params;
  var self = this;

  try {
    params = openVeoApi.util.shallowValidateObject(request.params, {
      id: {type: &#x27;string&#x27;, required: true},
      tagid: {type: &#x27;string&#x27;}
    });
  } catch (error) {
    return next(HTTP_ERRORS.UPDATE_TAG_WRONG_PARAMETERS);
  }

  var mediaId = params.id;
  var tagId = params.tagid;
  var provider = this.getProvider();

  var parser = new MultipartParser(request, [
    {
      name: &#x27;file&#x27;,
      destinationPath: process.rootPublish + &#x27;/assets/player/videos/&#x27; + mediaId + &#x27;/uploads/&#x27;,
      maxCount: 1
    }
  ], {
    fileSize: 20 * 1000 * 1000
  });

  parser.parse(function(parseError) {
    if (parseError) {
      process.logger.error(parseError.message, {error: parseError, method: &#x27;updateTagAction&#x27;});
      return next(HTTP_ERRORS.UPDATE_TAG_UPLOAD_ERROR);
    }

    if (!request.body.info) return next(HTTP_ERRORS.UPDATE_TAG_MISSING_PARAMETERS);

    var tag = JSON.parse(request.body.info);
    var file = request.files.file ? request.files.file[0] : null;
    var filter = new ResourceFilter().equal(&#x27;id&#x27;, mediaId);
    tag.id = tagId;

    // Make sure user has enough privilege to update the media
    provider.getOne(
      filter,
      {
        include: [&#x27;id&#x27;, &#x27;metadata&#x27;]
      },
      function(getOneError, media) {
        if (getOneError) {
          process.logger.error(getOneError.message, {error: getOneError, method: &#x27;updateTagAction&#x27;});
          return next(HTTP_ERRORS.UPDATE_TAG_GET_ONE_ERROR);
        }
        if (!self.isUserAuthorized(request.user, media, ContentController.OPERATIONS.UPDATE))
          return next(HTTP_ERRORS.UPDATE_TAG_FORBIDDEN);

        provider.updateOneTag(filter, tag, file, function(updateError, total, tag) {
          if (updateError) {
            process.logger.error(updateError.message, {error: updateError, method: &#x27;updateTagAction&#x27;});
            return next(HTTP_ERRORS.UPDATE_TAG_ERROR);
          }

          response.send({total: total, tag: tag});
        });
      }
    );
  });
};

/**
 * Updates a chapter associated to the given media.
 *
 * If chapter does not exist it is created.
 *
 * @example
 *
 *     // Response example
 *     {
 *       &quot;total&quot;: 1,
 *       &quot;chapter&quot;: ...
 *     }
 *
 * @method updateChapterAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Object} [request.body] Request body
 * @param {Object} [request.body.info] Modifications to perform on the chapter
 * @param {Number} [request.body.info.value] The chapter time in milliseconds
 * @param {String} [request.body.info.name] The chapter name
 * @param {String} [request.body.info.description] The chapter description
 * @param {Object} request.params Request parameters
 * @param {String} request.params.id The media id the chapter belongs to
 * @param {String} [request.params.chapterid] The chapter id
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.updateChapterAction = function(request, response, next) {
  if (!request.params.id || !request.body) return next(HTTP_ERRORS.UPDATE_CHAPTER_MISSING_PARAMETERS);

  var params;
  var self = this;

  try {
    params = openVeoApi.util.shallowValidateObject(request.params, {
      id: {type: &#x27;string&#x27;, required: true},
      chapterid: {type: &#x27;string&#x27;}
    });
  } catch (error) {
    return next(HTTP_ERRORS.UPDATE_CHAPTER_WRONG_PARAMETERS);
  }

  var mediaId = params.id;
  var chapterId = params.chapterid;
  var chapter = request.body;
  var provider = this.getProvider();
  var filter = new ResourceFilter().equal(&#x27;id&#x27;, mediaId);
  chapter.id = chapterId;

  // Make sure user has enough privilege to update the media
  provider.getOne(
    filter,
    {
      include: [&#x27;id&#x27;, &#x27;metadata&#x27;]
    },
    function(getOneError, media) {
      if (getOneError) {
        process.logger.error(getOneError.message, {error: getOneError, method: &#x27;updateChapterAction&#x27;});
        return next(HTTP_ERRORS.UPDATE_CHAPTER_GET_ONE_ERROR);
      }
      if (!self.isUserAuthorized(request.user, media, ContentController.OPERATIONS.UPDATE))
        return next(HTTP_ERRORS.UPDATE_CHAPTER_FORBIDDEN);

      provider.updateOneChapter(filter, chapter, function(updateError, total, chapter) {
        if (updateError) {
          process.logger.error(updateError.message, {error: updateError, method: &#x27;updateChapterAction&#x27;});
          return next(HTTP_ERRORS.UPDATE_CHAPTER_ERROR);
        }

        response.send({total: total, chapter: chapter});
      });
    }
  );
};

/**
 * Removes tags from a media.
 *
 * @example
 *
 *     // Response example
 *     {
 *       &quot;total&quot;: 1
 *     }
 *
 * @method removeTagsAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Object} request.params Request parameters
 * @param {String} request.params.id The media id
 * @param {String} request.params.tagsids A comma separated list of tags ids to remove
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.removeTagsAction = function(request, response, next) {
  if (!request.params.id || !request.params.tagsids) return next(HTTP_ERRORS.REMOVE_TAGS_MISSING_PARAMETERS);

  var self = this;
  var params;

  try {
    params = openVeoApi.util.shallowValidateObject(request.params, {
      id: {type: &#x27;string&#x27;, required: true},
      tagsids: {type: &#x27;string&#x27;, required: true}
    });
  } catch (error) {
    return next(HTTP_ERRORS.REMOVE_TAGS_WRONG_PARAMETERS);
  }

  var tagsIds = params.tagsids.split(&#x27;,&#x27;);
  var provider = this.getProvider(request);
  var filter = new ResourceFilter().equal(&#x27;id&#x27;, params.id);

  // Make sure user has enough privilege to update the media
  provider.getOne(
    filter,
    {
      include: [&#x27;id&#x27;, &#x27;metadata&#x27;]
    },
    function(getOneError, media) {
      if (getOneError) {
        process.logger.error(getOneError.message, {error: getOneError, method: &#x27;removeTagsAction&#x27;});
        return next(HTTP_ERRORS.REMOVE_TAGS_GET_ONE_ERROR);
      }
      if (!self.isUserAuthorized(request.user, media, ContentController.OPERATIONS.UPDATE))
        return next(HTTP_ERRORS.REMOVE_TAGS_FORBIDDEN);

      provider.removeTags(filter, tagsIds, function(updateError, total) {
        if (updateError) {
          process.logger.error(updateError.message, {error: updateError, method: &#x27;removeTagsAction&#x27;});
          return next(HTTP_ERRORS.REMOVE_TAGS_ERROR);
        }

        response.send({total: total});
      });
    }
  );
};

/**
 * Removes chapters from a media.
 *
 * @example
 *
 *     // Response example
 *     {
 *       &quot;total&quot;: 1
 *     }
 *
 * @method removeChaptersAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Object} request.params Request parameters
 * @param {String} request.params.id The media id
 * @param {String} request.params.chaptersids A comma separated list of chapters ids to remove
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.removeChaptersAction = function(request, response, next) {
  if (!request.params.id || !request.params.chaptersids) return next(HTTP_ERRORS.REMOVE_CHAPTERS_MISSING_PARAMETERS);

  var self = this;
  var params;

  try {
    params = openVeoApi.util.shallowValidateObject(request.params, {
      id: {type: &#x27;string&#x27;, required: true},
      chaptersids: {type: &#x27;string&#x27;, required: true}
    });
  } catch (error) {
    return next(HTTP_ERRORS.REMOVE_CHAPTERS_WRONG_PARAMETERS);
  }

  var chaptersIds = params.chaptersids.split(&#x27;,&#x27;);
  var provider = this.getProvider(request);
  var filter = new ResourceFilter().equal(&#x27;id&#x27;, params.id);

  // Make sure user has enough privilege to update the media
  provider.getOne(
    filter,
    {
      include: [&#x27;id&#x27;, &#x27;metadata&#x27;]
    },
    function(getOneError, media) {
      if (getOneError) {
        process.logger.error(getOneError.message, {error: getOneError, method: &#x27;removeChaptersAction&#x27;});
        return next(HTTP_ERRORS.REMOVE_CHAPTERS_GET_ONE_ERROR);
      }
      if (!self.isUserAuthorized(request.user, media, ContentController.OPERATIONS.UPDATE))
        return next(HTTP_ERRORS.REMOVE_CHAPTERS_FORBIDDEN);

      provider.removeChapters(filter, chaptersIds, function(updateError, total) {
        if (updateError) {
          process.logger.error(updateError.message, {error: updateError, method: &#x27;removeChaptersAction&#x27;});
          return next(HTTP_ERRORS.REMOVE_CHAPTERS_ERROR);
        }

        response.send({total: total});
      });
    }
  );
};

/**
 * Converts points of interest (chapters, tags &amp; cut) units
 * from percents to milliseconds (depending on the video
 * duration).
 *
 * @example
 *
 *     // Response example
 *     {
 *       &quot;entity&quot;: ...
 *     }
 *
 * @method convertPoiAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Object} request.params Request parameters
 * @param {String} request.params.id The media id
 * @param {String} request.params.chaptersIds A comma separated list of chapters ids to remove
 * @param {String} request.body Information to convert points of interest
 * @param {Number} request.body.duration The media duration in milliseconds
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 */
VideoController.prototype.convertPoiAction = function(request, response, next) {
  if (!request.params.id || !request.body || !request.body.duration)
    return next(HTTP_ERRORS.CONVERT_POINTS_OF_INTEREST_MISSING_PARAMETERS);

  var params;
  var body;
  var self = this;

  try {
    params = openVeoApi.util.shallowValidateObject(request.params, {
      id: {type: &#x27;string&#x27;, required: true}
    });
    body = openVeoApi.util.shallowValidateObject(request.body, {
      duration: {type: &#x27;number&#x27;, required: true}
    });
  } catch (error) {
    return next(HTTP_ERRORS.CONVERT_POINTS_OF_INTEREST_WRONG_PARAMETERS);
  }

  var provider = this.getProvider();
  var duration = body.duration;
  var filter = new ResourceFilter().equal(&#x27;id&#x27;, params.id);

  // Get media
  provider.getOne(
    filter,
    null,
    function(getOneError, media) {
      if (getOneError) {
        process.logger.error(getOneError.message, {error: getOneError, method: &#x27;convertPoiAction&#x27;});
        return next(HTTP_ERRORS.CONVERT_POINTS_OF_INTEREST_GET_ONE_ERROR);
      }

      // Media not ready
      if (media.state !== STATES.READY &amp;&amp; media.state !== STATES.PUBLISHED)
        return next(HTTP_ERRORS.CONVERT_POINTS_OF_INTEREST_NOT_READY_ERROR);

      // User without enough privilege to read the media in ready state
      if (media.state === STATES.READY &amp;&amp;
          !self.isUserAuthorized(request.user, media, ContentController.OPERATIONS.READ)
         ) {
        return next(HTTP_ERRORS.CONVERT_POINTS_OF_INTEREST_FORBIDDEN);
      }

      if (!media.needPointsOfInterestUnitConversion) {
        resolveResourcesUrls([media]);

        return response.send({
          entity: media
        });
      }

      var properties = [&#x27;chapters&#x27;, &#x27;tags&#x27;, &#x27;cut&#x27;];

      for (var i = 0; i &lt; properties.length; i++) {
        if (Array.isArray(media[properties[i]])) {
          media[properties[i]].forEach(function(pointOfInterest) {
            pointOfInterest.value = Math.floor(pointOfInterest.value * duration);
          });
        } else {
          media[properties[i]] = [];
        }
      }

      delete media.needPointsOfInterestUnitConversion;

      provider.updateOne(
        filter,
        {
          chapters: media.chapters,
          cut: media.cut,
          tags: media.tags
        },
        function(updateError, total) {
          if (updateError) {
            process.logger.error(updateError.message, {error: updateError, method: &#x27;convertPoiAction&#x27;});
            return next(HTTP_ERRORS.CONVERT_VIDEO_POI_ERROR);
          }

          resolveResourcesUrls([media]);

          response.send({
            entity: media
          });
        }
      );
    }
  );
};

/**
 * Gets the id of the super administrator.
 *
 * @method getSuperAdminId
 * @return {String} The id of the super admin
 */
VideoController.prototype.getSuperAdminId = function() {
  return process.api.getCoreApi().getSuperAdminId();
};

/**
 * Gets the id of the anonymous user.
 *
 * @method getAnonymousId
 * @return {String} The id of the anonymous user
 */
VideoController.prototype.getAnonymousId = function() {
  return process.api.getCoreApi().getAnonymousUserId();
};

/**
 * Tests if user is a contents manager.
 *
 * A contents manager can perform CRUD operations on medias.
 *
 * @method isUserManager
 * @param {Object} user The user to test
 * @param {Array} user.permissions The user&#x27;s permissions
 * @return {Boolean} true if the user has permission to manage medias, false otherwise
 */
VideoController.prototype.isUserManager = function(user) {
  if (!user || !user.permissions) return false;

  for (var i = 0; i &lt; user.permissions.length; i++) {
    if (user.permissions[i] === &#x27;publish-manage-videos&#x27;) return true;
  }
  return false;
};

/**
 * Adds medias.
 *
 * It is not possible to add several medias at a time.
 *
 * @method addEntitiesAction
 * @async
 * @param {Request} request ExpressJS HTTP Request
 * @param {Response} response ExpressJS HTTP Response
 * @param {Function} next Function to defer execution to the next registered middleware
 * @throws {Error} Function is not implemented for this controller
 */
VideoController.prototype.addEntitiesAction = function(request, response, next) {
  throw new Error(&#x27;addEntitiesAction method not available for medias&#x27;);
};

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
